<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sonar Battleship</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');

        body {
            background-color: #051a05;
            color: #4ade80;
            font-family: 'VT323', monospace;
            overflow-x: hidden;
            -webkit-font-smoothing: antialiased;
            touch-action: manipulation; /* Improves touch response */
        }

        /* CRT Scanline Effect */
        .scanline {
            width: 100%;
            height: 100px;
            z-index: 10;
            background: linear-gradient(0deg, rgba(0,0,0,0) 0%, rgba(74, 222, 128, 0.1) 50%, rgba(0,0,0,0) 100%);
            opacity: 0.1;
            position: absolute;
            bottom: 100%;
            animation: scanline 10s linear infinite;
            pointer-events: none;
        }

        @keyframes scanline {
            0% { bottom: 100%; }
            100% { bottom: -100px; }
        }

        .crt-flicker {
            animation: flicker 0.15s infinite;
        }

        @keyframes flicker {
            0% { opacity: 0.95; }
            50% { opacity: 1.0; }
            100% { opacity: 0.98; }
        }

        .grid-cell {
            aspect-ratio: 1;
            border: 1px solid #14532d;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.7rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .grid-cell:hover {
            background-color: #14532d;
        }

        .grid-cell.hit { background-color: #ef4444; box-shadow: 0 0 10px #ef4444; border-color: #ef4444; }
        .grid-cell.miss { background-color: #9ca3af; opacity: 0.5; }
        .grid-cell.ship { background-color: #4ade80; box-shadow: 0 0 5px #4ade80; }
        .grid-cell.sunk { background-color: #7f1d1d; border-color: #ef4444; }

        .sonar-container {
            position: relative;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: 2px solid #4ade80;
            overflow: hidden;
            background: #000;
        }
        
        .sonar-sweep {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 50%;
            height: 2px;
            background: #4ade80;
            transform-origin: 0 0;
            animation: sweep 2s infinite linear;
            box-shadow: 0 0 10px #4ade80;
        }

        @keyframes sweep {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .modal {
            background: rgba(5, 26, 5, 0.95);
            border: 2px solid #4ade80;
            box-shadow: 0 0 20px #4ade80;
        }

        @media (max-width: 600px) {
            .grid-label { font-size: 0.6rem; }
        }
    </style>
</head>
<body class="min-h-screen flex flex-col crt-flicker relative">
    <div class="scanline"></div>

    <!-- Initialization Overlay -->
    <div id="initOverlay" class="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-95 p-4">
        <div class="modal max-w-md w-full p-6 text-center">
            <h1 class="text-4xl mb-4 font-bold tracking-widest text-green-400">SONAR BATTLESHIP</h1>
            <p class="mb-6 text-green-200 text-lg">
                This game uses high-frequency audio to communicate with your opponent.
                <br><br>
                1. Open on two devices nearby.<br>
                2. Turn volume UP (70%).<br>
                3. Grant Mic permissions.
            </p>
            <div class="flex flex-col gap-4 justify-center">
                 <button id="initBtn" onclick="app.init()" class="bg-green-600 hover:bg-green-500 text-black font-bold py-3 px-8 text-xl rounded shadow-[0_0_15px_rgba(74,222,128,0.5)] transition-all">
                    INITIALIZE COMMS
                </button>
                
                <div class="flex items-center justify-center gap-2 mt-2">
                    <input type="checkbox" id="audibleMode" class="w-5 h-5 accent-green-500">
                    <label for="audibleMode" class="text-green-300">Audible Mode (Debug)</label>
                </div>
            </div>
            <p class="mt-4 text-xs text-green-700">Warning: Requires quiet environment.</p>
        </div>
    </div>

    <!-- Main Game UI -->
    <div id="gameUI" class="flex-grow flex flex-col p-2 md:p-4 hidden">
        
        <header class="flex justify-between items-center mb-4 border-b border-green-800 pb-2">
            <div class="flex items-center gap-4">
                <div class="sonar-container">
                    <div class="sonar-sweep"></div>
                </div>
                <div>
                    <h1 class="text-2xl font-bold leading-none">SONAR LINK</h1>
                    <div id="connectionStatus" class="text-sm text-green-500 animate-pulse">STANDBY</div>
                </div>
            </div>
            <div class="text-right">
                <div id="phaseDisplay" class="text-xl font-bold text-yellow-400">SETUP PHASE</div>
                <div class="text-xs text-green-600">FREQ: <span id="freqDisplay">--</span> Hz</div>
            </div>
        </header>

        <div class="h-16 w-full bg-black border border-green-900 mb-4 relative overflow-hidden rounded">
            <canvas id="visualizer" class="w-full h-full opacity-50"></canvas>
            <div class="absolute top-1 left-2 text-xs text-green-700">SPECTRUM ANALYZER</div>
        </div>

        <div class="flex flex-col md:flex-row gap-4 md:gap-8 justify-center items-start flex-grow">
            
            <div class="w-full max-w-[400px] mx-auto">
                <div class="flex justify-between mb-1">
                    <h2 class="text-lg">ENEMY SECTOR</h2>
                    <span id="enemyStatus" class="text-sm text-red-400">TARGETING...</span>
                </div>
                <div id="enemyGrid" class="grid grid-cols-10 gap-0.5 bg-green-900 border-2 border-green-700 p-1 shadow-[0_0_15px_rgba(74,222,128,0.2)]">
                </div>
            </div>

            <div class="w-full max-w-[400px] mx-auto">
                <div class="flex justify-between mb-1">
                    <h2 class="text-lg">HOME SECTOR</h2>
                    <div class="flex gap-2">
                         <button id="autoPlaceBtn" onclick="game.autoPlaceShips()" class="text-xs bg-green-800 px-2 py-1 hover:bg-green-700 border border-green-600">AUTO-PLACE</button>
                         <button id="resetBtn" onclick="game.resetBoard()" class="text-xs bg-red-900 px-2 py-1 hover:bg-red-800 border border-red-600">CLEAR</button>
                    </div>
                </div>
                <div id="playerGrid" class="grid grid-cols-10 gap-0.5 bg-black border-2 border-green-900 p-1 opacity-90">
                </div>
            </div>

        </div>

        <div class="mt-4 border-t border-green-900 pt-2">
            <div class="flex justify-between items-end">
                <div id="gameLog" class="h-24 w-full md:w-2/3 overflow-y-auto text-sm text-green-400 font-mono bg-black bg-opacity-50 p-2 border border-green-900">
                    <div>> SYSTEM INITIALIZED...</div>
                </div>
                <div class="ml-4 flex flex-col gap-2 w-1/3 md:w-auto">
                    <button id="startGameBtn" onclick="game.finalizeSetup()" class="bg-green-600 text-black font-bold py-2 px-4 rounded hover:bg-green-500 shadow-lg hidden">
                        START MISSION
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- CONFIGURATION ---
        const CONFIG = {
            MODES: {
                ULTRASONIC: { mark: 19000, space: 18000, preamble: 17500 },
                AUDIBLE: { mark: 880, space: 440, preamble: 660 }
            },
            BIT_DURATION: 0.08, 
            PREAMBLE_DURATION: 0.4, 
            GRID_SIZE: 10,
            SHIPS: [5, 4, 3, 3, 2] 
        };

        // --- AUDIO MODEM CLASS ---
        class AudioModem {
            constructor() {
                this.ctx = null;
                this.analyser = null;
                this.isListening = false;
                this.msgQueue = [];
                this.callback = null;
                this.mode = 'ULTRASONIC';
                this.threshold = -50;
                this.lastDetectTime = 0;
            }

            async init(mode = 'ULTRASONIC') {
                this.mode = mode;
                
                // 1. Context Creation (Must be sync in click handler)
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                
                if (!AudioContext) {
                    alert("Your browser does not support Web Audio API.");
                    return false;
                }

                try {
                    this.ctx = new AudioContext();
                    // iOS/Android require resuming state if started 'suspended'
                    if (this.ctx.state === 'suspended') {
                        await this.ctx.resume();
                    }
                } catch (e) {
                    alert("Could not create Audio Context: " + e.message);
                    return false;
                }
                
                // 2. Microphone Access
                try {
                    // Check if mediaDevices exists (could be undefined in insecure contexts)
                    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                        alert("Microphone API not available. Ensure you are using HTTPS (GitHub Pages) or localhost.");
                        return false;
                    }

                    const stream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false } });
                    const source = this.ctx.createMediaStreamSource(stream);
                    this.analyser = this.ctx.createAnalyser();
                    this.analyser.fftSize = 2048;
                    this.analyser.smoothingTimeConstant = 0.5;
                    source.connect(this.analyser);
                    
                    this.startListening();
                    return true;
                } catch (e) {
                    console.error("Mic Error:", e);
                    alert("Microphone access denied or error: " + e.name + " - " + e.message + "\n\nCheck your browser permissions settings.");
                    return false;
                }
            }

            getFreqs() { return CONFIG.MODES[this.mode]; }

            async transmit(type, payload) {
                if(this.ctx.state === 'suspended') await this.ctx.resume();
                
                let bits = [];
                for(let i=0; i<4; i++) bits.push((type >> i) & 1);
                for(let i=0; i<8; i++) bits.push((payload >> i) & 1);

                app.log(`Transmitting: TYPE ${type}, PAYLOAD ${payload}`);
                this.playSequence(bits);
            }

            playSequence(bits) {
                const freqs = this.getFreqs();
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                
                const now = this.ctx.currentTime;
                let t = now;

                // Preamble
                osc.frequency.setValueAtTime(freqs.preamble, t);
                gain.gain.setValueAtTime(1, t);
                t += CONFIG.PREAMBLE_DURATION;

                // Gap
                gain.gain.setValueAtTime(0, t);
                t += 0.05;

                // Start Bit
                osc.frequency.setValueAtTime(freqs.mark, t);
                gain.gain.setValueAtTime(1, t);
                t += CONFIG.BIT_DURATION;

                // Data
                bits.forEach(bit => {
                    const f = bit === 1 ? freqs.mark : freqs.space;
                    osc.frequency.setValueAtTime(f, t);
                    t += CONFIG.BIT_DURATION;
                });

                // Stop Bit
                osc.frequency.setValueAtTime(freqs.space, t);
                t += CONFIG.BIT_DURATION;

                osc.stop(t);
                
                const duration = (t - now) * 1000;
                const statusEl = document.getElementById('connectionStatus');
                statusEl.innerText = "TRANSMITTING...";
                statusEl.classList.remove('text-green-500');
                statusEl.classList.add('text-yellow-400');
                
                setTimeout(() => {
                    statusEl.innerText = "LISTENING...";
                    statusEl.classList.add('text-green-500');
                    statusEl.classList.remove('text-yellow-400');
                }, duration);
            }

            startListening() {
                this.isListening = true;
                const bufferLength = this.analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                
                const processFrame = () => {
                    if (!this.isListening) return;
                    requestAnimationFrame(processFrame);
                    this.analyser.getByteFrequencyData(dataArray);
                    this.drawVisualizer(dataArray);
                    this.detectSignal(dataArray);
                };
                processFrame();
            }

            detectSignal(dataArray) {
                const freqs = this.getFreqs();
                const sampleRate = this.ctx.sampleRate;
                const binSize = sampleRate / (this.analyser.fftSize); 

                const getEnergy = (f) => {
                    const bin = Math.floor(f / binSize);
                    return (dataArray[bin-1] + dataArray[bin] + dataArray[bin+1]) / 3; 
                };

                const preambleEnergy = getEnergy(freqs.preamble);
                const now = Date.now();

                if (now - this.lastDetectTime < 2000) return; 

                // Simple Threshold check
                if (preambleEnergy > 150) {
                    console.log("Preamble Detected!");
                    this.lastDetectTime = now; 
                    
                    const statusEl = document.getElementById('connectionStatus');
                    statusEl.innerText = "RECEIVING SIGNAL...";
                    statusEl.classList.add('text-red-500');
                    
                    setTimeout(() => {
                        this.readMessage();
                    }, (CONFIG.PREAMBLE_DURATION * 1000) + 20); 
                }
            }

            async readMessage() {
                const freqs = this.getFreqs();
                const binSize = this.ctx.sampleRate / (this.analyser.fftSize);
                const dataArray = new Uint8Array(this.analyser.frequencyBinCount);

                const bitsToRead = 14; 
                let rawBits = [];

                const sample = () => {
                    this.analyser.getByteFrequencyData(dataArray);
                    const markE = (dataArray[Math.floor(freqs.mark/binSize)] || 0);
                    const spaceE = (dataArray[Math.floor(freqs.space/binSize)] || 0);
                    return markE > spaceE ? 1 : 0;
                };

                let bitIndex = 0;
                const interval = setInterval(() => {
                    const bit = sample();
                    rawBits.push(bit);
                    bitIndex++;

                    if(bitIndex >= bitsToRead) {
                        clearInterval(interval);
                        this.decodeMessage(rawBits);
                        
                        const statusEl = document.getElementById('connectionStatus');
                        statusEl.innerText = "LISTENING...";
                        statusEl.classList.remove('text-red-500');
                    }
                }, CONFIG.BIT_DURATION * 1000);
            }

            decodeMessage(rawBits) {
                console.log("Raw Bits:", rawBits);
                let type = 0;
                for(let i=0; i<4; i++) {
                    if(rawBits[1+i]) type |= (1 << i);
                }

                let payload = 0;
                for(let i=0; i<8; i++) {
                    if(rawBits[5+i]) payload |= (1 << i);
                }
                
                app.log(`Received: TYPE ${type}, DATA ${payload}`);
                if (this.callback) this.callback(type, payload);
            }

            drawVisualizer(dataArray) {
                const canvas = document.getElementById("visualizer");
                const canvasCtx = canvas.getContext("2d");
                const width = canvas.width;
                const height = canvas.height;

                canvasCtx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                canvasCtx.fillRect(0, 0, width, height);

                let startBin = this.mode === 'ULTRASONIC' ? 800 : 0;
                let endBin = this.mode === 'ULTRASONIC' ? 1000 : 200;
                let x = 0;

                canvasCtx.beginPath();
                canvasCtx.strokeStyle = '#4ade80';
                canvasCtx.lineWidth = 1;

                for(let i = startBin; i < endBin; i++) {
                    const barHeight = dataArray[i];
                    const y = height - (barHeight / 255 * height);
                    if(i===startBin) canvasCtx.moveTo(x, y);
                    else canvasCtx.lineTo(x, y);
                    x += width / (endBin - startBin);
                }
                canvasCtx.stroke();
            }
        }

        // --- GAME LOGIC ---
        class BattleshipGame {
            constructor(modem) {
                this.modem = modem;
                this.myBoard = Array(100).fill(0); 
                this.enemyBoard = Array(100).fill(0); 
                this.myShips = []; 
                this.phase = 'SETUP'; 
                this.lastTarget = -1;
            }

            init() {
                this.renderGrid('playerGrid', this.myBoard, true);
                this.renderGrid('enemyGrid', this.enemyBoard, false);
                this.modem.callback = (t, p) => this.handleMessage(t, p);
            }

            renderGrid(elementId, boardData, isPlayer) {
                const el = document.getElementById(elementId);
                el.innerHTML = '';
                boardData.forEach((cell, idx) => {
                    const div = document.createElement('div');
                    div.className = 'grid-cell';
                    
                    const row = Math.floor(idx / 10);
                    const col = idx % 10;
                    
                    if (isPlayer && cell === 1) div.classList.add('ship');
                    if (cell === 2) div.classList.add('hit');
                    if (cell === 3) div.classList.add('miss');
                    if (cell === 4) div.classList.add('sunk');

                    if (!isPlayer) {
                         div.onclick = () => this.handleGridClick(idx);
                    }
                    el.appendChild(div);
                });
            }

            autoPlaceShips() {
                this.myBoard.fill(0);
                this.myShips = [];
                CONFIG.SHIPS.forEach(size => {
                    let placed = false;
                    while (!placed) {
                        const horizontal = Math.random() > 0.5;
                        const row = Math.floor(Math.random() * 10);
                        const col = Math.floor(Math.random() * 10);
                        const idx = row * 10 + col;
                        if (this.canPlace(idx, size, horizontal)) {
                            this.placeShip(idx, size, horizontal);
                            placed = true;
                        }
                    }
                });
                this.renderGrid('playerGrid', this.myBoard, true);
                document.getElementById('startGameBtn').classList.remove('hidden');
                app.log("Ships repositioned.");
            }

            canPlace(startIdx, size, horizontal) {
                const r = Math.floor(startIdx / 10);
                const c = startIdx % 10;
                if (horizontal) {
                    if (c + size > 10) return false;
                    for(let i=0; i<size; i++) if(this.myBoard[startIdx + i] !== 0) return false;
                } else {
                    if (r + size > 10) return false;
                    for(let i=0; i<size; i++) if(this.myBoard[startIdx + i*10] !== 0) return false;
                }
                return true;
            }

            placeShip(startIdx, size, horizontal) {
                const indices = [];
                for(let i=0; i<size; i++) {
                    const idx = horizontal ? startIdx + i : startIdx + i*10;
                    this.myBoard[idx] = 1;
                    indices.push(idx);
                }
                this.myShips.push({ indices, hits: 0 });
            }

            finalizeSetup() {
                if(this.myShips.length < 5) this.autoPlaceShips();
                this.phase = 'READY';
                document.getElementById('startGameBtn').classList.add('hidden');
                document.getElementById('autoPlaceBtn').classList.add('hidden');
                document.getElementById('resetBtn').classList.add('hidden');
                document.getElementById('phaseDisplay').innerText = "AWAITING FIRE";
                app.log("System Armed. Waiting for incoming signal or tap enemy grid to fire.");
            }

            resetBoard() {
                this.myBoard.fill(0);
                this.myShips = [];
                this.renderGrid('playerGrid', this.myBoard, true);
                document.getElementById('startGameBtn').classList.add('hidden');
            }

            handleGridClick(idx) {
                if (this.phase === 'SETUP') {
                    app.log("Setup not complete.");
                    return;
                }
                if (this.enemyBoard[idx] !== 0) {
                    app.log("Sector already targeted.");
                    return;
                }

                this.lastTarget = idx;
                // Visual Pending
                const cells = document.getElementById('enemyGrid').children;
                if(cells[idx]) cells[idx].style.backgroundColor = '#fef08a';

                const r = Math.floor(idx / 10);
                const c = idx % 10;
                app.log(`FIRING ON ${String.fromCharCode(65+r)}${c}...`);
                const payload = (r << 4) | c;
                this.modem.transmit(1, payload); 
                document.getElementById('phaseDisplay').innerText = "TRANSMITTING...";
            }

            handleMessage(type, payload) {
                if (type === 1) { // INCOMING FIRE
                    const r = (payload >> 4) & 0xF;
                    const c = payload & 0xF;
                    const idx = r * 10 + c;
                    
                    if (idx < 0 || idx >= 100) return; 

                    app.log(`INCOMING FIRE DETECTED: ${String.fromCharCode(65+r)}${c}`);
                    
                    let result = 0; 
                    if (this.myBoard[idx] === 1) {
                        this.myBoard[idx] = 2; 
                        result = 1; 
                        const ship = this.myShips.find(s => s.indices.includes(idx));
                        if(ship) {
                            ship.hits++;
                            if(ship.hits >= ship.indices.length) {
                                result = 2; 
                                ship.indices.forEach(i => this.myBoard[i] = 4);
                            }
                        }
                    } else if (this.myBoard[idx] === 0) {
                        this.myBoard[idx] = 3; 
                    }

                    this.renderGrid('playerGrid', this.myBoard, true);
                    
                    setTimeout(() => {
                        this.modem.transmit(2, result);
                    }, 2000);
                    
                    document.getElementById('phaseDisplay').innerText = "ENEMY TURN";
                }
                else if (type === 2) { // RESULT
                    const result = payload; 
                    app.log(`TARGET REPORT: ${result === 0 ? "MISS" : (result === 2 ? "SHIP SUNK!" : "HIT")}`);
                    
                    if(this.lastTarget !== -1) {
                        if(result === 0) this.enemyBoard[this.lastTarget] = 3; 
                        else if(result === 1) this.enemyBoard[this.lastTarget] = 2; 
                        else if(result === 2) this.enemyBoard[this.lastTarget] = 4; 
                        this.renderGrid('enemyGrid', this.enemyBoard, false);
                        this.lastTarget = -1;
                    }

                    document.getElementById('phaseDisplay').innerText = "READY TO FIRE";
                }
            }
        }

        const app = {
            modem: new AudioModem(),
            game: null,
            init: async () => {
                const btn = document.getElementById('initBtn');
                btn.innerText = "REQUESTING...";
                
                const audible = document.getElementById('audibleMode').checked;
                const mode = audible ? 'AUDIBLE' : 'ULTRASONIC';
                
                try {
                    const success = await app.modem.init(mode);
                    if(success) {
                        document.getElementById('initOverlay').classList.add('hidden');
                        document.getElementById('gameUI').classList.remove('hidden');
                        document.getElementById('gameUI').classList.add('flex');
                        
                        app.game = new BattleshipGame(app.modem);
                        app.game.init();
                        window.game = app.game; 
                        app.log(`COMMS ONLINE. MODE: ${mode}`);
                    } else {
                         btn.innerText = "RETRY INITIALIZE";
                    }
                } catch(e) {
                    alert("Initialization failed: " + e.message);
                    btn.innerText = "RETRY INITIALIZE";
                }
            },
            log: (msg) => {
                const el = document.getElementById('gameLog');
                if(!el) return;
                const line = document.createElement('div');
                line.innerText = `> ${msg}`;
                el.appendChild(line);
                el.scrollTop = el.scrollHeight;
            }
        };
    </script>
</body>
</html>
